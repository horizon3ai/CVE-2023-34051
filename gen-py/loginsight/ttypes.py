#
# Autogenerated by Thrift Compiler (0.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class StrataNodeType(object):
    STANDALONE = 1
    WORKER = 2
    UNKNOWN = 3

    _VALUES_TO_NAMES = {
        1: "STANDALONE",
        2: "WORKER",
        3: "UNKNOWN",
    }

    _NAMES_TO_VALUES = {
        "STANDALONE": 1,
        "WORKER": 2,
        "UNKNOWN": 3,
    }


class RepoImportCommand(object):
    """
    Attributes:
     - path
     - interval
     - monitor
     - parserName
     - inclusion
     - exclusion

    """


    def __init__(self, path=None, interval=None, monitor=None, parserName=None, inclusion=None, exclusion=None,):
        self.path = path
        self.interval = interval
        self.monitor = monitor
        self.parserName = parserName
        self.inclusion = inclusion
        self.exclusion = exclusion

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.interval = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.monitor = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.parserName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.inclusion = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.exclusion = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RepoImportCommand')
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 1)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        if self.interval is not None:
            oprot.writeFieldBegin('interval', TType.I32, 2)
            oprot.writeI32(self.interval)
            oprot.writeFieldEnd()
        if self.monitor is not None:
            oprot.writeFieldBegin('monitor', TType.BOOL, 3)
            oprot.writeBool(self.monitor)
            oprot.writeFieldEnd()
        if self.parserName is not None:
            oprot.writeFieldBegin('parserName', TType.STRING, 4)
            oprot.writeString(self.parserName.encode('utf-8') if sys.version_info[0] == 2 else self.parserName)
            oprot.writeFieldEnd()
        if self.inclusion is not None:
            oprot.writeFieldBegin('inclusion', TType.STRING, 5)
            oprot.writeString(self.inclusion.encode('utf-8') if sys.version_info[0] == 2 else self.inclusion)
            oprot.writeFieldEnd()
        if self.exclusion is not None:
            oprot.writeFieldBegin('exclusion', TType.STRING, 6)
            oprot.writeString(self.exclusion.encode('utf-8') if sys.version_info[0] == 2 else self.exclusion)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ShutdownCommand(object):
    """
    Attributes:
     - immediately
     - waitForQueued

    """


    def __init__(self, immediately=None, waitForQueued=None,):
        self.immediately = immediately
        self.waitForQueued = waitForQueued

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.immediately = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.waitForQueued = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ShutdownCommand')
        if self.immediately is not None:
            oprot.writeFieldBegin('immediately', TType.BOOL, 1)
            oprot.writeBool(self.immediately)
            oprot.writeFieldEnd()
        if self.waitForQueued is not None:
            oprot.writeFieldBegin('waitForQueued', TType.BOOL, 2)
            oprot.writeBool(self.waitForQueued)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RestartCommand(object):
    """
    Attributes:
     - waitForQueued

    """


    def __init__(self, waitForQueued=None,):
        self.waitForQueued = waitForQueued

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.waitForQueued = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RestartCommand')
        if self.waitForQueued is not None:
            oprot.writeFieldBegin('waitForQueued', TType.BOOL, 1)
            oprot.writeBool(self.waitForQueued)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PhoneHomeFeedbackCommand(object):
    """
    Attributes:
     - enable

    """


    def __init__(self, enable=None,):
        self.enable = enable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PhoneHomeFeedbackCommand')
        if self.enable is not None:
            oprot.writeFieldBegin('enable', TType.BOOL, 1)
            oprot.writeBool(self.enable)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class HostSyncCommand(object):
    """
    Attributes:
     - ntpModeAttributeString

    """


    def __init__(self, ntpModeAttributeString=None,):
        self.ntpModeAttributeString = ntpModeAttributeString

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ntpModeAttributeString = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('HostSyncCommand')
        if self.ntpModeAttributeString is not None:
            oprot.writeFieldBegin('ntpModeAttributeString', TType.STRING, 1)
            oprot.writeString(self.ntpModeAttributeString.encode('utf-8') if sys.version_info[0] == 2 else self.ntpModeAttributeString)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NtpSyncCommand(object):
    """
    Attributes:
     - test
     - ntpServers

    """


    def __init__(self, test=None, ntpServers=None,):
        self.test = test
        self.ntpServers = ntpServers

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.test = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ntpServers = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.ntpServers.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NtpSyncCommand')
        if self.test is not None:
            oprot.writeFieldBegin('test', TType.BOOL, 1)
            oprot.writeBool(self.test)
            oprot.writeFieldEnd()
        if self.ntpServers is not None:
            oprot.writeFieldBegin('ntpServers', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.ntpServers))
            for iter6 in self.ntpServers:
                oprot.writeString(iter6.encode('utf-8') if sys.version_info[0] == 2 else iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SupportBundleCommand(object):
    """
    Attributes:
     - uuid

    """


    def __init__(self, uuid=None,):
        self.uuid = uuid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.uuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SupportBundleCommand')
        if self.uuid is not None:
            oprot.writeFieldBegin('uuid', TType.STRING, 1)
            oprot.writeString(self.uuid.encode('utf-8') if sys.version_info[0] == 2 else self.uuid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PakUpgradeCommand(object):
    """
    Attributes:
     - fileName
     - eulaOnly
     - outputFile
     - outputOnly
     - locale
     - forceInstall

    """


    def __init__(self, fileName=None, eulaOnly=None, outputFile=None, outputOnly=None, locale=None, forceInstall=None,):
        self.fileName = fileName
        self.eulaOnly = eulaOnly
        self.outputFile = outputFile
        self.outputOnly = outputOnly
        self.locale = locale
        self.forceInstall = forceInstall

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.eulaOnly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.outputFile = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.outputOnly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.locale = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.forceInstall = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PakUpgradeCommand')
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 1)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        if self.eulaOnly is not None:
            oprot.writeFieldBegin('eulaOnly', TType.BOOL, 2)
            oprot.writeBool(self.eulaOnly)
            oprot.writeFieldEnd()
        if self.outputFile is not None:
            oprot.writeFieldBegin('outputFile', TType.STRING, 3)
            oprot.writeString(self.outputFile.encode('utf-8') if sys.version_info[0] == 2 else self.outputFile)
            oprot.writeFieldEnd()
        if self.outputOnly is not None:
            oprot.writeFieldBegin('outputOnly', TType.BOOL, 4)
            oprot.writeBool(self.outputOnly)
            oprot.writeFieldEnd()
        if self.locale is not None:
            oprot.writeFieldBegin('locale', TType.STRING, 5)
            oprot.writeString(self.locale.encode('utf-8') if sys.version_info[0] == 2 else self.locale)
            oprot.writeFieldEnd()
        if self.forceInstall is not None:
            oprot.writeFieldBegin('forceInstall', TType.BOOL, 6)
            oprot.writeBool(self.forceInstall)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RemotePakDownloadCommand(object):
    """
    Attributes:
     - sourceNodeToken
     - requestUrl
     - fileName

    """


    def __init__(self, sourceNodeToken=None, requestUrl=None, fileName=None,):
        self.sourceNodeToken = sourceNodeToken
        self.requestUrl = requestUrl
        self.fileName = fileName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sourceNodeToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.requestUrl = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RemotePakDownloadCommand')
        if self.sourceNodeToken is not None:
            oprot.writeFieldBegin('sourceNodeToken', TType.STRING, 1)
            oprot.writeString(self.sourceNodeToken.encode('utf-8') if sys.version_info[0] == 2 else self.sourceNodeToken)
            oprot.writeFieldEnd()
        if self.requestUrl is not None:
            oprot.writeFieldBegin('requestUrl', TType.STRING, 2)
            oprot.writeString(self.requestUrl.encode('utf-8') if sys.version_info[0] == 2 else self.requestUrl)
            oprot.writeFieldEnd()
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 3)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConfigLolCommand(object):
    """
    Attributes:
     - operation
     - destination
     - protocol
     - port
     - force

    """


    def __init__(self, operation=None, destination=None, protocol=None, port=None, force=None,):
        self.operation = operation
        self.destination = destination
        self.protocol = protocol
        self.port = port
        self.force = force

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.operation = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.destination = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.protocol = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.port = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.force = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConfigLolCommand')
        if self.operation is not None:
            oprot.writeFieldBegin('operation', TType.STRING, 1)
            oprot.writeString(self.operation.encode('utf-8') if sys.version_info[0] == 2 else self.operation)
            oprot.writeFieldEnd()
        if self.destination is not None:
            oprot.writeFieldBegin('destination', TType.STRING, 2)
            oprot.writeString(self.destination.encode('utf-8') if sys.version_info[0] == 2 else self.destination)
            oprot.writeFieldEnd()
        if self.protocol is not None:
            oprot.writeFieldBegin('protocol', TType.STRING, 3)
            oprot.writeString(self.protocol.encode('utf-8') if sys.version_info[0] == 2 else self.protocol)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.STRING, 4)
            oprot.writeString(self.port.encode('utf-8') if sys.version_info[0] == 2 else self.port)
            oprot.writeFieldEnd()
        if self.force is not None:
            oprot.writeFieldBegin('force', TType.STRING, 5)
            oprot.writeString(self.force.encode('utf-8') if sys.version_info[0] == 2 else self.force)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CommandWithTimeout(object):
    """
    Attributes:
     - command
     - timeoutMillis

    """


    def __init__(self, command=None, timeoutMillis=None,):
        self.command = command
        self.timeoutMillis = timeoutMillis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.command = Command()
                    self.command.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timeoutMillis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommandWithTimeout')
        if self.command is not None:
            oprot.writeFieldBegin('command', TType.STRUCT, 1)
            self.command.write(oprot)
            oprot.writeFieldEnd()
        if self.timeoutMillis is not None:
            oprot.writeFieldBegin('timeoutMillis', TType.I64, 2)
            oprot.writeI64(self.timeoutMillis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Command(object):
    """
    Attributes:
     - commandType
     - repoImportCommand
     - shutdownCommand
     - restartCommand
     - phoneHomeFeedbackCommand
     - hostSyncCommand
     - ntpSyncCommand
     - supportBundleCommand
     - pakUpgradeCommand
     - remotePakDownloadCommand
     - configLolCommand

    """


    def __init__(self, commandType=None, repoImportCommand=None, shutdownCommand=None, restartCommand=None, phoneHomeFeedbackCommand=None, hostSyncCommand=None, ntpSyncCommand=None, supportBundleCommand=None, pakUpgradeCommand=None, remotePakDownloadCommand=None, configLolCommand=None,):
        self.commandType = commandType
        self.repoImportCommand = repoImportCommand
        self.shutdownCommand = shutdownCommand
        self.restartCommand = restartCommand
        self.phoneHomeFeedbackCommand = phoneHomeFeedbackCommand
        self.hostSyncCommand = hostSyncCommand
        self.ntpSyncCommand = ntpSyncCommand
        self.supportBundleCommand = supportBundleCommand
        self.pakUpgradeCommand = pakUpgradeCommand
        self.remotePakDownloadCommand = remotePakDownloadCommand
        self.configLolCommand = configLolCommand

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.commandType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.repoImportCommand = RepoImportCommand()
                    self.repoImportCommand.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.shutdownCommand = ShutdownCommand()
                    self.shutdownCommand.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.restartCommand = RestartCommand()
                    self.restartCommand.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.phoneHomeFeedbackCommand = PhoneHomeFeedbackCommand()
                    self.phoneHomeFeedbackCommand.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.hostSyncCommand = HostSyncCommand()
                    self.hostSyncCommand.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.ntpSyncCommand = NtpSyncCommand()
                    self.ntpSyncCommand.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.supportBundleCommand = SupportBundleCommand()
                    self.supportBundleCommand.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.pakUpgradeCommand = PakUpgradeCommand()
                    self.pakUpgradeCommand.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.remotePakDownloadCommand = RemotePakDownloadCommand()
                    self.remotePakDownloadCommand.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.configLolCommand = ConfigLolCommand()
                    self.configLolCommand.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Command')
        if self.commandType is not None:
            oprot.writeFieldBegin('commandType', TType.I32, 1)
            oprot.writeI32(self.commandType)
            oprot.writeFieldEnd()
        if self.repoImportCommand is not None:
            oprot.writeFieldBegin('repoImportCommand', TType.STRUCT, 2)
            self.repoImportCommand.write(oprot)
            oprot.writeFieldEnd()
        if self.shutdownCommand is not None:
            oprot.writeFieldBegin('shutdownCommand', TType.STRUCT, 3)
            self.shutdownCommand.write(oprot)
            oprot.writeFieldEnd()
        if self.restartCommand is not None:
            oprot.writeFieldBegin('restartCommand', TType.STRUCT, 4)
            self.restartCommand.write(oprot)
            oprot.writeFieldEnd()
        if self.phoneHomeFeedbackCommand is not None:
            oprot.writeFieldBegin('phoneHomeFeedbackCommand', TType.STRUCT, 5)
            self.phoneHomeFeedbackCommand.write(oprot)
            oprot.writeFieldEnd()
        if self.hostSyncCommand is not None:
            oprot.writeFieldBegin('hostSyncCommand', TType.STRUCT, 6)
            self.hostSyncCommand.write(oprot)
            oprot.writeFieldEnd()
        if self.ntpSyncCommand is not None:
            oprot.writeFieldBegin('ntpSyncCommand', TType.STRUCT, 7)
            self.ntpSyncCommand.write(oprot)
            oprot.writeFieldEnd()
        if self.supportBundleCommand is not None:
            oprot.writeFieldBegin('supportBundleCommand', TType.STRUCT, 8)
            self.supportBundleCommand.write(oprot)
            oprot.writeFieldEnd()
        if self.pakUpgradeCommand is not None:
            oprot.writeFieldBegin('pakUpgradeCommand', TType.STRUCT, 9)
            self.pakUpgradeCommand.write(oprot)
            oprot.writeFieldEnd()
        if self.remotePakDownloadCommand is not None:
            oprot.writeFieldBegin('remotePakDownloadCommand', TType.STRUCT, 10)
            self.remotePakDownloadCommand.write(oprot)
            oprot.writeFieldEnd()
        if self.configLolCommand is not None:
            oprot.writeFieldBegin('configLolCommand', TType.STRUCT, 11)
            self.configLolCommand.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CommandStatusWithHandle(object):
    """
    Attributes:
     - commandStatus
     - commandHandle

    """


    def __init__(self, commandStatus=None, commandHandle=None,):
        self.commandStatus = commandStatus
        self.commandHandle = commandHandle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.commandStatus = CommandStatus()
                    self.commandStatus.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.commandHandle = CommandHandle()
                    self.commandHandle.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommandStatusWithHandle')
        if self.commandStatus is not None:
            oprot.writeFieldBegin('commandStatus', TType.STRUCT, 1)
            self.commandStatus.write(oprot)
            oprot.writeFieldEnd()
        if self.commandHandle is not None:
            oprot.writeFieldBegin('commandHandle', TType.STRUCT, 2)
            self.commandHandle.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CommandStatus(object):
    """
    Attributes:
     - commandStatusType
     - queuedCommandStatus
     - runningCommandStatus
     - exitedCommandStatus

    """


    def __init__(self, commandStatusType=None, queuedCommandStatus=None, runningCommandStatus=None, exitedCommandStatus=None,):
        self.commandStatusType = commandStatusType
        self.queuedCommandStatus = queuedCommandStatus
        self.runningCommandStatus = runningCommandStatus
        self.exitedCommandStatus = exitedCommandStatus

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.commandStatusType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.queuedCommandStatus = QueuedCommandStatus()
                    self.queuedCommandStatus.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.runningCommandStatus = RunningCommandStatus()
                    self.runningCommandStatus.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.exitedCommandStatus = ExitedCommandStatus()
                    self.exitedCommandStatus.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommandStatus')
        if self.commandStatusType is not None:
            oprot.writeFieldBegin('commandStatusType', TType.I32, 1)
            oprot.writeI32(self.commandStatusType)
            oprot.writeFieldEnd()
        if self.queuedCommandStatus is not None:
            oprot.writeFieldBegin('queuedCommandStatus', TType.STRUCT, 2)
            self.queuedCommandStatus.write(oprot)
            oprot.writeFieldEnd()
        if self.runningCommandStatus is not None:
            oprot.writeFieldBegin('runningCommandStatus', TType.STRUCT, 3)
            self.runningCommandStatus.write(oprot)
            oprot.writeFieldEnd()
        if self.exitedCommandStatus is not None:
            oprot.writeFieldBegin('exitedCommandStatus', TType.STRUCT, 4)
            self.exitedCommandStatus.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CommandHandle(object):
    """
    Attributes:
     - commandHandle
     - error

    """


    def __init__(self, commandHandle=None, error=None,):
        self.commandHandle = commandHandle
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.commandHandle = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.error = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommandHandle')
        if self.commandHandle is not None:
            oprot.writeFieldBegin('commandHandle', TType.I64, 1)
            oprot.writeI64(self.commandHandle)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRING, 2)
            oprot.writeString(self.error.encode('utf-8') if sys.version_info[0] == 2 else self.error)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueuedCommandStatus(object):
    """
    Attributes:
     - command
     - timeRequested

    """


    def __init__(self, command=None, timeRequested=None,):
        self.command = command
        self.timeRequested = timeRequested

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.command = Command()
                    self.command.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.timeRequested = Timestamp()
                    self.timeRequested.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueuedCommandStatus')
        if self.command is not None:
            oprot.writeFieldBegin('command', TType.STRUCT, 1)
            self.command.write(oprot)
            oprot.writeFieldEnd()
        if self.timeRequested is not None:
            oprot.writeFieldBegin('timeRequested', TType.STRUCT, 2)
            self.timeRequested.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RunningCommandStatus(object):
    """
    Attributes:
     - command
     - timeRequested
     - timeStartedRunning
     - lastStatusUpdate

    """


    def __init__(self, command=None, timeRequested=None, timeStartedRunning=None, lastStatusUpdate=None,):
        self.command = command
        self.timeRequested = timeRequested
        self.timeStartedRunning = timeStartedRunning
        self.lastStatusUpdate = lastStatusUpdate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.command = Command()
                    self.command.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.timeRequested = Timestamp()
                    self.timeRequested.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.timeStartedRunning = Timestamp()
                    self.timeStartedRunning.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.lastStatusUpdate = StatusUpdate()
                    self.lastStatusUpdate.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RunningCommandStatus')
        if self.command is not None:
            oprot.writeFieldBegin('command', TType.STRUCT, 1)
            self.command.write(oprot)
            oprot.writeFieldEnd()
        if self.timeRequested is not None:
            oprot.writeFieldBegin('timeRequested', TType.STRUCT, 2)
            self.timeRequested.write(oprot)
            oprot.writeFieldEnd()
        if self.timeStartedRunning is not None:
            oprot.writeFieldBegin('timeStartedRunning', TType.STRUCT, 3)
            self.timeStartedRunning.write(oprot)
            oprot.writeFieldEnd()
        if self.lastStatusUpdate is not None:
            oprot.writeFieldBegin('lastStatusUpdate', TType.STRUCT, 4)
            self.lastStatusUpdate.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExitedCommandStatus(object):
    """
    Attributes:
     - command
     - timeRequested
     - timeStartedRunning
     - lastStatusUpdate
     - exitTime
     - wasCancelled

    """


    def __init__(self, command=None, timeRequested=None, timeStartedRunning=None, lastStatusUpdate=None, exitTime=None, wasCancelled=None,):
        self.command = command
        self.timeRequested = timeRequested
        self.timeStartedRunning = timeStartedRunning
        self.lastStatusUpdate = lastStatusUpdate
        self.exitTime = exitTime
        self.wasCancelled = wasCancelled

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.command = Command()
                    self.command.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.timeRequested = Timestamp()
                    self.timeRequested.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.timeStartedRunning = Timestamp()
                    self.timeStartedRunning.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.lastStatusUpdate = StatusUpdate()
                    self.lastStatusUpdate.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.exitTime = Timestamp()
                    self.exitTime.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.wasCancelled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExitedCommandStatus')
        if self.command is not None:
            oprot.writeFieldBegin('command', TType.STRUCT, 1)
            self.command.write(oprot)
            oprot.writeFieldEnd()
        if self.timeRequested is not None:
            oprot.writeFieldBegin('timeRequested', TType.STRUCT, 2)
            self.timeRequested.write(oprot)
            oprot.writeFieldEnd()
        if self.timeStartedRunning is not None:
            oprot.writeFieldBegin('timeStartedRunning', TType.STRUCT, 3)
            self.timeStartedRunning.write(oprot)
            oprot.writeFieldEnd()
        if self.lastStatusUpdate is not None:
            oprot.writeFieldBegin('lastStatusUpdate', TType.STRUCT, 4)
            self.lastStatusUpdate.write(oprot)
            oprot.writeFieldEnd()
        if self.exitTime is not None:
            oprot.writeFieldBegin('exitTime', TType.STRUCT, 5)
            self.exitTime.write(oprot)
            oprot.writeFieldEnd()
        if self.wasCancelled is not None:
            oprot.writeFieldBegin('wasCancelled', TType.BOOL, 6)
            oprot.writeBool(self.wasCancelled)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class StatusUpdate(object):
    """
    Attributes:
     - statusMessage
     - timestamp
     - error
     - exitCode

    """


    def __init__(self, statusMessage=None, timestamp=None, error=None, exitCode=None,):
        self.statusMessage = statusMessage
        self.timestamp = timestamp
        self.error = error
        self.exitCode = exitCode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.statusMessage = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.timestamp = Timestamp()
                    self.timestamp.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.error = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.exitCode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('StatusUpdate')
        if self.statusMessage is not None:
            oprot.writeFieldBegin('statusMessage', TType.STRING, 1)
            oprot.writeString(self.statusMessage.encode('utf-8') if sys.version_info[0] == 2 else self.statusMessage)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.STRUCT, 2)
            self.timestamp.write(oprot)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.BOOL, 3)
            oprot.writeBool(self.error)
            oprot.writeFieldEnd()
        if self.exitCode is not None:
            oprot.writeFieldBegin('exitCode', TType.I32, 4)
            oprot.writeI32(self.exitCode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Timestamp(object):
    """
    Attributes:
     - timestamp

    """


    def __init__(self, timestamp=None,):
        self.timestamp = timestamp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Timestamp')
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 1)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetConfigRequest(object):
    """
    Attributes:
     - clusterGuid
     - workerToken
     - lastKnownConfigGeneration
     - includeBlobInResponseIFFNewerVersion

    """


    def __init__(self, clusterGuid=None, workerToken=None, lastKnownConfigGeneration=None, includeBlobInResponseIFFNewerVersion=None,):
        self.clusterGuid = clusterGuid
        self.workerToken = workerToken
        self.lastKnownConfigGeneration = lastKnownConfigGeneration
        self.includeBlobInResponseIFFNewerVersion = includeBlobInResponseIFFNewerVersion

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.clusterGuid = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.workerToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.lastKnownConfigGeneration = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.includeBlobInResponseIFFNewerVersion = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetConfigRequest')
        if self.clusterGuid is not None:
            oprot.writeFieldBegin('clusterGuid', TType.STRING, 1)
            oprot.writeString(self.clusterGuid.encode('utf-8') if sys.version_info[0] == 2 else self.clusterGuid)
            oprot.writeFieldEnd()
        if self.workerToken is not None:
            oprot.writeFieldBegin('workerToken', TType.STRING, 2)
            oprot.writeString(self.workerToken.encode('utf-8') if sys.version_info[0] == 2 else self.workerToken)
            oprot.writeFieldEnd()
        if self.lastKnownConfigGeneration is not None:
            oprot.writeFieldBegin('lastKnownConfigGeneration', TType.I32, 3)
            oprot.writeI32(self.lastKnownConfigGeneration)
            oprot.writeFieldEnd()
        if self.includeBlobInResponseIFFNewerVersion is not None:
            oprot.writeFieldBegin('includeBlobInResponseIFFNewerVersion', TType.BOOL, 4)
            oprot.writeBool(self.includeBlobInResponseIFFNewerVersion)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class GetConfigResult(object):
    """
    Attributes:
     - masterToken
     - configGeneration
     - configBlob
     - error

    """


    def __init__(self, masterToken=None, configGeneration=None, configBlob=None, error=None,):
        self.masterToken = masterToken
        self.configGeneration = configGeneration
        self.configBlob = configBlob
        self.error = error

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.masterToken = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.configGeneration = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.configBlob = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.error = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('GetConfigResult')
        if self.masterToken is not None:
            oprot.writeFieldBegin('masterToken', TType.STRING, 1)
            oprot.writeString(self.masterToken.encode('utf-8') if sys.version_info[0] == 2 else self.masterToken)
            oprot.writeFieldEnd()
        if self.configGeneration is not None:
            oprot.writeFieldBegin('configGeneration', TType.I32, 2)
            oprot.writeI32(self.configGeneration)
            oprot.writeFieldEnd()
        if self.configBlob is not None:
            oprot.writeFieldBegin('configBlob', TType.STRING, 3)
            oprot.writeString(self.configBlob.encode('utf-8') if sys.version_info[0] == 2 else self.configBlob)
            oprot.writeFieldEnd()
        if self.error is not None:
            oprot.writeFieldBegin('error', TType.STRING, 4)
            oprot.writeString(self.error.encode('utf-8') if sys.version_info[0] == 2 else self.error)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(RepoImportCommand)
RepoImportCommand.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'path', 'UTF8', None, ),  # 1
    (2, TType.I32, 'interval', None, None, ),  # 2
    (3, TType.BOOL, 'monitor', None, None, ),  # 3
    (4, TType.STRING, 'parserName', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'inclusion', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'exclusion', 'UTF8', None, ),  # 6
)
all_structs.append(ShutdownCommand)
ShutdownCommand.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'immediately', None, None, ),  # 1
    (2, TType.BOOL, 'waitForQueued', None, None, ),  # 2
)
all_structs.append(RestartCommand)
RestartCommand.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'waitForQueued', None, None, ),  # 1
)
all_structs.append(PhoneHomeFeedbackCommand)
PhoneHomeFeedbackCommand.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enable', None, None, ),  # 1
)
all_structs.append(HostSyncCommand)
HostSyncCommand.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ntpModeAttributeString', 'UTF8', None, ),  # 1
)
all_structs.append(NtpSyncCommand)
NtpSyncCommand.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'test', None, None, ),  # 1
    (2, TType.LIST, 'ntpServers', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(SupportBundleCommand)
SupportBundleCommand.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'uuid', 'UTF8', None, ),  # 1
)
all_structs.append(PakUpgradeCommand)
PakUpgradeCommand.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'fileName', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'eulaOnly', None, None, ),  # 2
    (3, TType.STRING, 'outputFile', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'outputOnly', None, None, ),  # 4
    (5, TType.STRING, 'locale', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'forceInstall', None, None, ),  # 6
)
all_structs.append(RemotePakDownloadCommand)
RemotePakDownloadCommand.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sourceNodeToken', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'requestUrl', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'fileName', 'UTF8', None, ),  # 3
)
all_structs.append(ConfigLolCommand)
ConfigLolCommand.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'operation', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'destination', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'protocol', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'port', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'force', 'UTF8', None, ),  # 5
)
all_structs.append(CommandWithTimeout)
CommandWithTimeout.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'command', [Command, None], None, ),  # 1
    (2, TType.I64, 'timeoutMillis', None, None, ),  # 2
)
all_structs.append(Command)
Command.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'commandType', None, None, ),  # 1
    (2, TType.STRUCT, 'repoImportCommand', [RepoImportCommand, None], None, ),  # 2
    (3, TType.STRUCT, 'shutdownCommand', [ShutdownCommand, None], None, ),  # 3
    (4, TType.STRUCT, 'restartCommand', [RestartCommand, None], None, ),  # 4
    (5, TType.STRUCT, 'phoneHomeFeedbackCommand', [PhoneHomeFeedbackCommand, None], None, ),  # 5
    (6, TType.STRUCT, 'hostSyncCommand', [HostSyncCommand, None], None, ),  # 6
    (7, TType.STRUCT, 'ntpSyncCommand', [NtpSyncCommand, None], None, ),  # 7
    (8, TType.STRUCT, 'supportBundleCommand', [SupportBundleCommand, None], None, ),  # 8
    (9, TType.STRUCT, 'pakUpgradeCommand', [PakUpgradeCommand, None], None, ),  # 9
    (10, TType.STRUCT, 'remotePakDownloadCommand', [RemotePakDownloadCommand, None], None, ),  # 10
    (11, TType.STRUCT, 'configLolCommand', [ConfigLolCommand, None], None, ),  # 11
)
all_structs.append(CommandStatusWithHandle)
CommandStatusWithHandle.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'commandStatus', [CommandStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'commandHandle', [CommandHandle, None], None, ),  # 2
)
all_structs.append(CommandStatus)
CommandStatus.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'commandStatusType', None, None, ),  # 1
    (2, TType.STRUCT, 'queuedCommandStatus', [QueuedCommandStatus, None], None, ),  # 2
    (3, TType.STRUCT, 'runningCommandStatus', [RunningCommandStatus, None], None, ),  # 3
    (4, TType.STRUCT, 'exitedCommandStatus', [ExitedCommandStatus, None], None, ),  # 4
)
all_structs.append(CommandHandle)
CommandHandle.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'commandHandle', None, None, ),  # 1
    (2, TType.STRING, 'error', 'UTF8', None, ),  # 2
)
all_structs.append(QueuedCommandStatus)
QueuedCommandStatus.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'command', [Command, None], None, ),  # 1
    (2, TType.STRUCT, 'timeRequested', [Timestamp, None], None, ),  # 2
)
all_structs.append(RunningCommandStatus)
RunningCommandStatus.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'command', [Command, None], None, ),  # 1
    (2, TType.STRUCT, 'timeRequested', [Timestamp, None], None, ),  # 2
    (3, TType.STRUCT, 'timeStartedRunning', [Timestamp, None], None, ),  # 3
    (4, TType.STRUCT, 'lastStatusUpdate', [StatusUpdate, None], None, ),  # 4
)
all_structs.append(ExitedCommandStatus)
ExitedCommandStatus.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'command', [Command, None], None, ),  # 1
    (2, TType.STRUCT, 'timeRequested', [Timestamp, None], None, ),  # 2
    (3, TType.STRUCT, 'timeStartedRunning', [Timestamp, None], None, ),  # 3
    (4, TType.STRUCT, 'lastStatusUpdate', [StatusUpdate, None], None, ),  # 4
    (5, TType.STRUCT, 'exitTime', [Timestamp, None], None, ),  # 5
    (6, TType.BOOL, 'wasCancelled', None, None, ),  # 6
)
all_structs.append(StatusUpdate)
StatusUpdate.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'statusMessage', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'timestamp', [Timestamp, None], None, ),  # 2
    (3, TType.BOOL, 'error', None, None, ),  # 3
    (4, TType.I32, 'exitCode', None, None, ),  # 4
)
all_structs.append(Timestamp)
Timestamp.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'timestamp', None, None, ),  # 1
)
all_structs.append(GetConfigRequest)
GetConfigRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'clusterGuid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'workerToken', 'UTF8', None, ),  # 2
    (3, TType.I32, 'lastKnownConfigGeneration', None, None, ),  # 3
    (4, TType.BOOL, 'includeBlobInResponseIFFNewerVersion', None, None, ),  # 4
)
all_structs.append(GetConfigResult)
GetConfigResult.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'masterToken', 'UTF8', None, ),  # 1
    (2, TType.I32, 'configGeneration', None, None, ),  # 2
    (3, TType.STRING, 'configBlob', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'error', 'UTF8', None, ),  # 4
)
fix_spec(all_structs)
del all_structs
